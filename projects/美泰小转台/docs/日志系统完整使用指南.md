# 日志系统完整使用指南

## 概述

本项目使用基于 spdlog 的统一日志系统，支持多种输出方式和灵活的配置。日志系统采用单例模式，线程安全，支持异步处理。

## 系统架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   应用代码      │───▶│   Logger单例    │───▶│   多种输出目标  │
│ (使用日志宏)    │    │  (统一管理)     │    │  (文件/UI/控制台)│
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 主要组件

### 1. Logger 类
- **位置**: `include/core/Logger.h`, `src/core/Logger.cpp`
- **功能**: 日志系统的核心管理类，单例模式
- **特性**: 
  - 线程安全
  - 异步处理
  - 模块化日志支持
  - 多种输出目标（Sink）

### 2. LogDisplayWidget 类
- **位置**: `include/ui/LogDisplayWidget.h`, `src/ui/LogDisplayWidget.cpp`
- **功能**: UI日志显示组件
- **特性**:
  - 实时日志显示
  - 模块过滤
  - 日志级别过滤
  - 日志保存功能

### 3. 日志输出目标（Sink）
- **CallbackSink**: 转发日志到UI回调
- **QtDebugSink**: 输出到Qt调试系统
- **RotatingFileSink**: 轮转文件输出

## 使用方法

### 1. 系统初始化

```cpp
// 在main函数或应用启动时初始化
TesterFramework::Logger::getInstance().initialize("app.log");
```

### 2. 基础日志记录

```cpp
// 使用基础日志宏
LOG_TRACE("详细的调试信息");
LOG_DEBUG("调试信息");
LOG_INFO("一般信息");
LOG_WARNING("警告信息");
LOG_ERROR("错误信息");
LOG_CRITICAL("严重错误");
```

### 3. 模块化日志记录（推荐）

```cpp
// 为不同模块记录日志
LOG_MODULE_INFO("DeviceManager", "设备初始化完成");
LOG_MODULE_ERROR("NetworkModule", "连接失败: {}", errorMsg);
LOG_MODULE_DEBUG("ConfigLoader", "加载配置文件: {}", filename);

// 支持格式化字符串（fmt风格）
LOG_MODULE_INFO("BurnDevice", "设备发现: IP={}, Port={}", ip, port);
```

### 4. 特殊用途日志

```cpp
// 使用预定义的特殊logger
LOG_SUCCESS("操作成功完成");
LOG_EVENT("用户点击了按钮");
LOG_CONFIG("配置文件已更新");
LOG_STATUS("系统状态更新");
```

### 5. 高级用法

```cpp
// 获取特定模块的logger
auto logger = TesterFramework::Logger::getInstance().getLogger("MyModule");
logger->info("模块日志");
logger->error("模块错误");

// 设置模块日志级别
TesterFramework::Logger::getInstance().setModuleLevel("MyModule", TesterFramework::LogLevel::Debug);

// 设置全局日志级别
TesterFramework::Logger::getInstance().setLevel(TesterFramework::LogLevel::Info);
```

## 日志级别

| 级别 | 数值 | 说明 | 使用场景 |
|------|------|------|----------|
| Trace | 0 | 最详细的调试信息 | 深度调试 |
| Debug | 1 | 调试信息 | 开发调试 |
| Info | 2 | 一般信息 | 正常运行信息 |
| Warning | 3 | 警告信息 | 潜在问题 |
| Error | 4 | 错误信息 | 程序错误 |
| Critical | 5 | 严重错误 | 系统崩溃 |

## 日志格式

### spdlog 格式
```
[LEVEL] [ModuleName] Message
```

### UI 显示格式
```
[HH:MM:SS.mmm] [LEVEL] [ModuleName] Message
```

## 常见问题与解决方案

### 1. 日志不显示在UI中

**原因**: 
- 日志级别过滤
- 模块过滤设置
- LogDisplayWidget未正确初始化

**解决方案**:
```cpp
// 检查日志级别设置
TesterFramework::Logger::getInstance().setModuleLevel("YourModule", TesterFramework::LogLevel::Debug);

// 检查UI过滤器设置
logDisplayWidget->setMinLogLevel(TesterFramework::LogLevel::Debug);
```

**调试步骤**:
1. 检查控制台是否有调试输出（LogDisplayWidget临时添加的）
2. 确认模块名是否正确提取
3. 验证日志级别是否匹配

### 2. 时间戳重复

**原因**: spdlog和UI都添加了时间戳

**解决方案**: 
- spdlog格式不包含时间戳：`[%^%l%$] [%n] %v`
- UI在显示时添加时间戳

### 3. 中文乱码

**原因**: 控制台输出编码问题

**解决方案**: 
- 移除console sink
- 使用QtDebugSink输出到Qt调试系统

### 4. 模块过滤不工作

**原因**: 模块名提取失败

**解决方案**:
- 使用正确的LOG_MODULE_*宏
- 确保spdlog格式包含模块名(%n)
- 检查extractModuleName()方法的正则表达式

## 最佳实践

### 1. 模块命名规范
- 使用有意义的模块名
- 采用PascalCase命名风格
- 避免使用日志级别作为模块名

```cpp
// 好的示例
LOG_MODULE_INFO("DeviceManager", "设备初始化完成");
LOG_MODULE_ERROR("TcpChannel", "连接失败");
LOG_MODULE_DEBUG("ConfigLoader", "加载配置");

// 避免
LOG_MODULE_INFO("INFO", "消息");  // 模块名和级别冲突
LOG_MODULE_INFO("device", "消息");  // 模块名应该更具体
```

### 2. 日志消息格式
- 使用清晰的消息描述
- 包含必要的上下文信息
- 支持格式化参数

```cpp
// 好的示例
LOG_MODULE_INFO("BurnDevice", "设备发现: IP={}, MAC={}", ip, mac);
LOG_MODULE_ERROR("NetworkModule", "连接失败: {}，重试次数: {}", error, retryCount);

// 避免
LOG_MODULE_INFO("BurnDevice", "ok");  // 消息不够清晰
LOG_MODULE_ERROR("NetworkModule", "error");  // 缺少上下文
```

### 3. 日志级别使用
- **Debug**: 详细的调试信息，生产环境通常关闭
- **Info**: 重要的运行状态信息
- **Warning**: 潜在问题，不影响正常运行
- **Error**: 程序错误，需要关注
- **Critical**: 严重错误，可能导致程序崩溃

### 4. 性能考虑
- 避免在循环中记录大量日志
- 使用合适的日志级别
- 利用异步特性，避免阻塞主线程

```cpp
// 好的示例
if (Logger::getInstance().getLogger("MyModule")->should_log(spdlog::level::debug)) {
    LOG_MODULE_DEBUG("MyModule", "详细的调试信息: {}", expensiveFunction());
}

// 避免
for (int i = 0; i < 1000000; ++i) {
    LOG_MODULE_DEBUG("MyModule", "处理项目: {}", i);  // 可能产生大量日志
}
```

## 系统配置

### 1. 文件输出配置
- 日志文件保存在 `logs/` 目录下
- 支持文件轮转（5MB一个文件，保留3个文件）
- 自动刷新频率：1秒

### 2. UI显示配置
- 默认最大行数：1000行
- 支持实时过滤
- 自动滚动到底部

### 3. 线程池配置
- 缓冲区大小：8192字节
- 后台线程数：1个
- 溢出策略：阻塞

## 故障排除

### 1. 检查清单
- [ ] 确保调用了 `Logger::getInstance().initialize()`
- [ ] 确认日志级别设置正确
- [ ] 确认UI过滤器设置正确
- [ ] 确认UI更新在主线程中进行
- [ ] 确认spdlog格式包含模块名

### 2. 调试技巧

#### 启用调试模式
在LogDisplayWidget中临时添加了调试输出，可以在控制台查看：
```cpp
qDebug() << "LogDisplayWidget收到日志:" << "Level:" << static_cast<int>(level) << "Module:" << moduleName << "Message:" << message;
```

#### 检查日志流程
1. 应用代码调用日志宏
2. spdlog处理并格式化
3. CallbackSink转发到LogDisplayWidget
4. LogDisplayWidget应用过滤和显示

#### 常见调试命令
```cpp
// 查看所有已注册的logger
auto loggers = Logger::getInstance().getRegisteredLoggerNames();

// 临时降低日志级别
Logger::getInstance().setLevel(LogLevel::Trace);

// 检查特定模块的日志级别
auto level = Logger::getInstance().getModuleLevel("BurnDevice");
```

### 3. 具体问题排除

#### BurnDevice日志不显示
```cpp
// 1. 检查BurnDevice模块级别
LOG_MODULE_INFO("BurnDevice", "测试消息");

// 2. 临时降低LogDisplayWidget过滤级别
logDisplayWidget->setMinLogLevel(TesterFramework::LogLevel::Trace);

// 3. 检查模块名提取
// 在extractModuleName()中添加调试输出
```

#### 模块过滤失效
```cpp
// 1. 检查正则表达式匹配
QRegularExpression moduleRegex1(R"(\[.*?\]\s*\[([^\]]+)\])");
QRegularExpressionMatch match1 = moduleRegex1.match(message);
if (match1.hasMatch()) {
    qDebug() << "提取到模块名:" << match1.captured(1);
}

// 2. 检查过滤逻辑
if (!m_moduleFilter.isEmpty()) {
    qDebug() << "当前过滤器:" << m_moduleFilter;
}
```

## 实际使用示例

### 1. 设备管理模块
```cpp
class DeviceManager {
public:
    void initialize() {
        LOG_MODULE_INFO("DeviceManager", "设备管理器初始化开始");
        
        // 初始化逻辑
        
        LOG_MODULE_INFO("DeviceManager", "设备管理器初始化完成，发现{}个设备", deviceCount);
    }
    
    void connectDevice(const QString& deviceId) {
        LOG_MODULE_DEBUG("DeviceManager", "尝试连接设备: {}", deviceId.toStdString());
        
        if (/* 连接失败 */) {
            LOG_MODULE_ERROR("DeviceManager", "设备连接失败: {}, 错误: {}", deviceId.toStdString(), error.toStdString());
            return;
        }
        
        LOG_MODULE_INFO("DeviceManager", "设备连接成功: {}", deviceId.toStdString());
    }
};
```

### 2. 网络通信模块
```cpp
class NetworkModule {
public:
    void sendData(const QByteArray& data) {
        LOG_MODULE_DEBUG("NetworkModule", "发送数据: 长度={} 字节", data.size());
        
        if (/* 发送失败 */) {
            LOG_MODULE_ERROR("NetworkModule", "数据发送失败: 长度={}, 错误={}", data.size(), error.toStdString());
            return;
        }
        
        LOG_MODULE_TRACE("NetworkModule", "数据发送成功: {}", data.toHex().toStdString());
    }
};
```

### 3. 配置管理模块
```cpp
class ConfigManager {
public:
    void loadConfig(const QString& filePath) {
        LOG_MODULE_INFO("ConfigManager", "加载配置文件: {}", filePath.toStdString());
        
        if (!QFile::exists(filePath)) {
            LOG_MODULE_WARNING("ConfigManager", "配置文件不存在: {}, 使用默认配置", filePath.toStdString());
            return;
        }
        
        // 加载逻辑
        
        LOG_MODULE_INFO("ConfigManager", "配置文件加载完成: {} 项配置", configCount);
    }
};
```

## 更新历史

- **v1.0**: 基础日志系统
- **v1.1**: 添加模块化支持
- **v1.2**: 修复时间戳重复问题
- **v1.3**: 改进模块名提取逻辑
- **v1.4**: 添加UI调试信息
- **v1.5**: 修复spdlog格式，添加模块名支持
- **v1.6**: 完善故障排除和调试指南

## 联系方式

如有问题，请联系开发团队或查看相关文档。
