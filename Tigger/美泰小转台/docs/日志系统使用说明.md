# 日志系统使用说明

## 概述

本项目使用基于spdlog的统一日志系统，提供了线程安全、高性能的日志记录功能。日志系统支持多种输出方式，包括文件、控制台、Qt调试输出和UI显示。

## 主要特性

- **单例模式**：全局唯一的Logger实例
- **线程安全**：支持多线程环境下的日志记录
- **异步处理**：不阻塞主线程的日志输出
- **模块化**：支持按模块分类的日志记录
- **多重输出**：同时输出到文件、控制台和UI
- **灵活配置**：支持不同模块的独立日志级别控制

## 初始化

在使用日志系统前，需要先初始化：

```cpp
// 在main函数或应用程序启动时
TesterFramework::Logger::getInstance().initialize("app.log");
```

## 日志级别

系统支持以下日志级别（从低到高）：

- **Trace**：最详细的调试信息
- **Debug**：调试信息
- **Info**：一般信息
- **Warning**：警告信息
- **Error**：错误信息
- **Critical**：严重错误

## 基本用法

### 1. 使用基础宏

```cpp
#include "core/Logger.h"

// 基础日志记录
LOG_TRACE("这是跟踪信息");
LOG_DEBUG("调试信息: 变量值 = 123");
LOG_INFO("系统启动完成");
LOG_WARNING("配置文件未找到，使用默认配置");
LOG_ERROR("文件打开失败");
LOG_CRITICAL("系统严重错误");
```

### 2. 使用模块化日志记录

```cpp
// 推荐的模块化日志记录方式
LOG_MODULE_INFO("DeviceManager", "设备初始化完成");
LOG_MODULE_ERROR("NetworkModule", "连接失败: 超时");
LOG_MODULE_DEBUG("ConfigLoader", "加载配置文件: config.json");

// 支持格式化字符串（spdlog格式）
LOG_MODULE_INFO("BurnDevice", "设备发现: IP={}, 端口={}", ip, port);
```

### 3. 使用特殊用途日志

```cpp
// 特殊分类的日志
LOG_SUCCESS("操作成功完成");
LOG_EVENT("用户点击了开始按钮");
LOG_CONFIG("配置更新: 新的超时时间为5秒");
LOG_STATUS("当前状态: 正在运行");
```

## 高级用法

### 1. 获取特定模块的Logger

```cpp
// 获取或创建模块Logger
auto logger = TesterFramework::Logger::getInstance().getLogger("MyModule");

// 使用logger记录日志
logger->info("这是模块日志");
logger->error("模块错误: {}", errorMessage);
```

### 2. 设置日志级别

```cpp
// 设置全局日志级别
TesterFramework::Logger::getInstance().setLevel(TesterFramework::LogLevel::Debug);

// 设置特定模块的日志级别
TesterFramework::Logger::getInstance().setModuleLevel("BurnDevice", TesterFramework::LogLevel::Debug);
TesterFramework::Logger::getInstance().setModuleLevel("NetworkModule", TesterFramework::LogLevel::Info);
```

### 3. 注册UI日志接收器

```cpp
// 注册自定义日志接收器（通常在UI初始化时）
TesterFramework::Logger::getInstance().addSink([](TesterFramework::LogLevel level, const std::string& message) {
    // 处理日志消息，如显示在UI中
    switch (level) {
        case TesterFramework::LogLevel::Error:
            // 显示错误消息
            break;
        case TesterFramework::LogLevel::Info:
            // 显示普通信息
            break;
        // ... 其他级别的处理
    }
});
```

## 模块化最佳实践

### 1. 为每个主要组件创建专用模块

```cpp
// 设备管理模块
class DeviceManager {
public:
    void initialize() {
        LOG_MODULE_INFO("DeviceManager", "开始初始化设备管理器");
        // ... 初始化逻辑
        LOG_MODULE_INFO("DeviceManager", "设备管理器初始化完成");
    }
    
    void connectDevice(const QString& deviceId) {
        LOG_MODULE_DEBUG("DeviceManager", "尝试连接设备: {}", deviceId.toStdString());
        if (/* 连接失败 */) {
            LOG_MODULE_ERROR("DeviceManager", "设备连接失败: {}", deviceId.toStdString());
        } else {
            LOG_MODULE_INFO("DeviceManager", "设备连接成功: {}", deviceId.toStdString());
        }
    }
};
```

### 2. 网络通信模块

```cpp
// 网络通信模块
class TcpChannel {
public:
    void connect(const QString& host, int port) {
        LOG_MODULE_INFO("TcpChannel", "尝试连接到 {}:{}", host.toStdString(), port);
        // ... 连接逻辑
    }
    
    void sendData(const QByteArray& data) {
        LOG_MODULE_DEBUG("TcpChannel", "发送数据: {} bytes", data.size());
        // ... 发送逻辑
    }
};
```

### 3. 设备特定模块

```cpp
// 烧录设备模块
class BurnDevice {
public:
    void processNotification(const QJsonObject& notification) {
        QString method = notification["method"].toString();
        LOG_MODULE_INFO("BurnDevice", "收到通知: {}", method.toStdString());
        
        if (method == "DeviceDiscovered") {
            QString ipHop = notification["params"]["ipHop"].toString();
            LOG_MODULE_INFO("BurnDevice", "设备发现通知: ipHop={}", ipHop.toStdString());
            
            // 记录设备详细信息
            QJsonObject deviceInfo = notification["params"]["device"].toObject();
            LOG_MODULE_DEBUG("BurnDevice", "设备信息: {}", 
                QJsonDocument(deviceInfo).toJson(QJsonDocument::Compact).toStdString());
        }
    }
};
```

## 日志格式说明

### 文件日志格式
```
[INFO] [2025-01-17 08:57:46.673] Server started successfully
[ERROR] [2025-01-17 08:57:46.674] Connection failed: timeout
```

### UI显示格式
```
[08:57:46.673] [INFO] Server started successfully
[08:57:46.674] [ERROR] Connection failed: timeout
```

## 配置建议

### 1. 开发阶段
```cpp
// 开发时使用详细日志
TesterFramework::Logger::getInstance().setLevel(TesterFramework::LogLevel::Debug);
TesterFramework::Logger::getInstance().setModuleLevel("BurnDevice", TesterFramework::LogLevel::Trace);
```

### 2. 生产环境
```cpp
// 生产环境使用较少的日志
TesterFramework::Logger::getInstance().setLevel(TesterFramework::LogLevel::Info);
TesterFramework::Logger::getInstance().setModuleLevel("NetworkModule", TesterFramework::LogLevel::Warning);
```

## 故障排除

### 1. 日志未显示在UI中
- 检查是否调用了`initialize()`
- 确认LogDisplayWidget正确注册了sink
- 检查日志级别设置是否过滤了消息

### 2. 模块日志过滤不工作
- 确认模块名称拼写正确
- 检查LogDisplayWidget的模块名提取逻辑
- 使用`getRegisteredLoggerNames()`查看已注册的模块

### 3. 重复时间戳问题
- 检查spdlog格式设置
- 确认UI格式化代码没有重复添加时间戳

## 性能考虑

1. **异步处理**：日志系统使用异步处理，不会阻塞主线程
2. **批量写入**：文件日志使用批量写入，提高性能
3. **缓冲区大小**：可以调整线程池缓冲区大小（默认8192）
4. **日志级别**：适当设置日志级别，避免过多的调试信息

## 示例代码

完整的使用示例：

```cpp
#include "core/Logger.h"

class ExampleClass {
public:
    void doSomething() {
        // 获取专用logger
        auto logger = TesterFramework::Logger::getInstance().getLogger("ExampleClass");
        
        logger->info("开始执行某项操作");
        
        try {
            // 执行某些可能失败的操作
            performOperation();
            
            LOG_MODULE_SUCCESS("ExampleClass", "操作成功完成");
        } catch (const std::exception& e) {
            LOG_MODULE_ERROR("ExampleClass", "操作失败: {}", e.what());
            throw;
        }
    }
    
private:
    void performOperation() {
        LOG_MODULE_DEBUG("ExampleClass", "执行内部操作");
        // ... 实际操作
    }
};
```

这个日志系统提供了灵活、高效的日志记录功能，支持开发和生产环境的不同需求。通过合理使用模块化日志和级别控制，可以大大提高问题诊断和系统监控的效率。
